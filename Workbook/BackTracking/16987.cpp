#include <bits/stdc++.h>

using namespace std;

int n;
int s[10], w[10];
int mx = 0;
int cnt = 0; // 깨져있는 계란의 수

void solve(int a){ // a번째 계란으로 다른걸 깰 차례
	if(a == n){
		mx = max(mx, cnt);
		return;
	}
	
	if(s[a] <= 0 || cnt == n - 1){
		solve(a + 1);
		return;
	} // a번째 계란이 깨져있거나 다른 모든 계란이 깨져있으면 넘어감
	
	for(int t = 0; t < n; t++){
		// t번째 계란을 내려치고 싶음
		if(t == a || s[t] <= 0) continue;
		s[a] -= w[t];
		s[t] -= w[a];
		if(s[a] <= 0) cnt++;
		if(s[t] <= 0) cnt++;
		solve(a+1);
		if(s[a] <= 0) cnt--;
		if(s[t] <= 0) cnt--;
		s[a] += w[t];
		s[t] += w[a];
	}
	
}

int main(){
	
	ios::sync_with_stdio(0); cin.tie(0);
	
	cin >> n;
	for(int i = 0; i < n; i++){
		cin >> s[i] >> w[i];
	}
	solve(0);
	cout << mx << '\n';
	
	return 0;
}

/*
계란으로 계란치기

계란은 내구도, 무게가 있음
계란 끼리 부딛히면 상대 계란의 무게만큼 내구도가 깎임(0이하)
일렬로 놓여있는 계란에 대해 왼쪽부터 차례로 들어서
한 번씩만 다른 계란을 쳐 최대한 많은 계란을 깨는 문제
1. 가장 왼쪽의 계란을 든다.
2. 손에 들고 있는 계란으로 깨지지 않은 다른 계란 중에서 하나를 친다.
	단 손에 든 계란이 깨졌거나 깨지지않은 다른 계란이 없으면 치지 않고 넘어간다.
	이후 손에 든 계란을 원래 자리에 내려놓고 3번 과정을 진행
3. 가장 최근에 든 계란의 한 칸 오른쪽 계란을 손에 들고 2번 과정 다시 진행
	단, 가장 최근에 든 계란이 가장 오른쪽에 위치한 계란일 경우 종료

이 과정을 통해 최대한 많은 계란을 깨는 것이 문제
일렬로 놓인 계란들의 내구도와 무게가 차례대로 주어졌을 때
최대 몇개의 계란을 깰 수 있는지 

문제 이해가 안되는데


*/