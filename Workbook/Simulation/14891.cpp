#include <bits/stdc++.h>

using namespace std;

list<char> wheel[5]; // 1 2 3 4 번 톱니바퀴 사용
int K;

void rotate(int i, int r){
	
	if(r == 1){
		wheel[i].push_back(wheel[i].front());
		wheel[i].pop_front();
	}else if(r == -1){
		wheel[i].push_front(wheel[i].back());
		wheel[i].pop_back();
	}
	
	
}

int main(){
	
	ios::sync_with_stdio(0); cin.tie(0);
	
	for(int i = 1; i < 5; i++){
		string s;
		cin >> s;
		
		for(auto it : s){
			wheel[i].push_back(it);
		}
	}	
	
	// cin >> K;
	
	// for(int i = 0; i < K; i++){
	// 	int w, r; // wheel num, rotate (1 ->) (-1 <-)
	// 	cin >> w >> r;
		
	// 	/*
	// 	돌리는 코드
	// 	string 빙글 빙글 도는 코드도 짜야할 듯
	// 	*/
	// }
	
	rotate(1,1);
	rotate(2,-1);
	cout << '\n';
	for(int i = 1; i < 5; i++){
		for(auto it : wheel[i]){
			cout << it;
		}
		cout << '\n';
	}
	
	
	
	return 0;
}

/*
1번 톱니바퀴 2번 톱니바퀴 w 변수값 
N극은 0 S극은 1
1. 일단 정해진 톱니바퀴 돌림
2. 그 양옆의 톱니바퀴 돌릴지 말지 판단후 돌려야 되면 돌림
3. 또 그 옆에 톱니바퀴 돌릴지 말지 판단

다 돌린후 각 톱니바퀴 배열의 0번지 값으로 점수 매겨서 결과값 출력

*/

/*
톱니바퀴

총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이
일렬로 놓여져 있다.
또 톱니는 N극 S극 중 하나를 나타내고 있다.
톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번
그 오른쪽은 3번 , 4번이다.
이때 톱니바퀴를 총 K번 회전시키려고 한다.
톱니바퀴의 회전은 한 칸을 기준으로 한다.
회전은 시계 방향과 반 시계방향이 있다.

톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다.
톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는
톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다.
톱니카뷔 A를 회전 할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면,
B는 A가 회전한 방향과 반대방향으로 회전하게 된다.

톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때,
최종 톱니바퀴의 상태를 구하는 프로그램

1번 톱니바퀴의 상태
2번 톱니바퀴의 상태
3번 톱니바퀴의 상태
4번 톱니바퀴의 상태
8개의 정수, 12시 방향부터 시계방향 순서대로 주어진다
N극은 0, S극은 1로

회전수 K(1<=K<=100)
다음 K줄 회전시킨 방법 두 개의 정수
첫 번째 회전시킨 톱니바퀴의 번호
두 번째 방향 1 시계방향 -1 반시계 방향

총 K번 회전시킨 이후에 네 톱바퀴의 점수의 합
1번 톱니바퀴의 12시 방향이 N극이면 0점 S극이면 1점
2번 톱니바퀴의 12시 방향이 N극이면 0점 S극이면 2점
3번 톱니바퀴의 12시 방향이 N극이면 0점 S극이면 4점
4번 톱니바퀴의 12시 방향이 N극이면 0점 S극이면 8점



*/