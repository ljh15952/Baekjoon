재귀(많이 어려움)
하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘





귀납적인 방식
1번 도미노가 쓰러진다.
k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다 == 참 => 모든 도미노가 쓰러진다.
-> 절차지향적인 사고 탈피

void func1(int n){
	if(n == 0) return;
	cout << n << ' ';
	func1(n-1);
}
=> 귀납적 사고
func1(1)이 1을 출력한다.
func1(k)가 k, k-1, k-2...1을 출력한다.
func1(k+1)은 k+1, k, k-1....1을 출력함을 보여야 함
func1(k+1) -> func(k)

int func2(int n){
	if(n == 0) return 0;
	return n+func2(n - 1);
}
=> 귀납적 사고!!
func2(1)은 1을 출력한다!
func2(k)는 k + k-1 + k-2 + .... 1을 출력한다.
func2(k+1)은 k+1 + k + k-1 + k-2 ... 1을 출력함
-> func2(n) 함수는 n부터 1까지 더한 합을 출력한다!!