재귀(많이 어려움)
하나의 함수에서 자기 자신을 다시 호출해 작업을 수행하는 알고리즘

귀납적인 방식
1번 도미노가 쓰러진다.
k번 도미노가 쓰러지면 k+1번 도미노도 쓰러진다 == 참 => 모든 도미노가 쓰러진다.
-> 절차지향적인 사고 탈피

void func1(int n){
	if(n == 0) return;
	cout << n << ' ';
	func1(n-1);
}
=> 귀납적 사고
func1(1)이 1을 출력한다.
func1(k)가 k, k-1, k-2...1을 출력한다.
func1(k+1)은 k+1, k, k-1....1을 출력함을 보여야 함
func1(k+1) -> func(k)

int func2(int n){
	if(n == 0) return 0;
	return n+func2(n - 1);
}
=> 귀납적 사고!!
func2(1)은 1을 출력한다!
func2(k)는 k + k-1 + k-2 + .... 1을 출력한다.
func2(k+1)은 k+1 + k + k-1 + k-2 ... 1을 출력함
-> func2(n) 함수는 n부터 1까지 더한 합을 출력한다!!

재귀 함수의 조건
- 특정 입력에 대해서는 자기 자신을 호출하지 않고 종료되어야 함(Base consition)
- 모든 입력은 base condition으로 수렴해야 함 (base case)
-> 조건이 지켜지지 않는다면 재귀 함수는 무한히 돌다가 런타임 에러 발생

정보
1. 함수의 인자로 어떤 것을 받고 어디까지 계산한 후 
자기 자신에게 넘겨줄지 명확하게 정해야 함
2. 모든 재귀 함수는 반복문만으로 동일한 동작을 하는 함수를 만들 수 있음
3. 재귀는 반복문으로 구현했을 때에 비해 코드가 간결하지만 메모리/시간에서는 손해를 봄
-> 어떨 때 재귀를 사용하면 유리하고 굳이 사용한해도 될때를 구별하는게 중요!

정보2
1.