#include <bits/stdc++.h>

using namespace std;

//원판 n개를 기둥a에서 기둥b으로 옮기는 방법을 출력하는 함수

/*
base condition
n == 1 일 때 cout << a << ' ' << b << '\n';
n == 0 일 때도 고민해보는게 좋음
*/

/*
재귀 식
n-1 개의 원판을 기둥 a에서 기둥 6-a-b로 옮긴다 
func(a, 6-a-b, n-1);
n번 원판을 기둥 a에서 기둥 b로 옮긴다.
cout << a << ' ' << b << '\n';
n-1개의 원판을 기둥 6-a-b에서 기둥 b로 옮긴다.
func(6-a-b, b, n-1)

*/

void func(int a,int b, int n){
	if(n == 1){
		cout << a << ' ' << b << '\n';
		return;
	}
	func(a, 6-a-b, n-1);
	cout << a << ' ' << b << '\n';
	func(6-a-b, b, n-1);
}



int main(){
	ios::sync_with_stdio(0); cin.tie(0);
	
	int k;
	cin >> k;
	cout << (1<<k) - 1 << '\n'; //2의 k 제곱 - 1
	func(1,3, k);
	
	return 0;
}

/*
하노이의 탑
 1
 2
 3
 ...
n-2
n-1
 n
기둥1		기둥2 	기둥3
n번 원판에 집중
n번 원판을 기둥3으로 옮기려면 n번 원판 위에 있는 1번부터 n-1번 까지의 원판들이
전부 비켜줘야 하고 이들은 전부 기둥2로 이동해야 함
-> 저것들 중 어느 하나라도 기둥3으로 가게될 경우 작은 원판 위에 큰 원판을 둘 수 없다는 규칙 위반

 		  1
          2
          3
         ...
         n-2
 n       n-1
기둥1		기둥2 	기둥3
n-1개의 원판을 기둥1에서 기둥2로 옮김 -> 이 후 n번 원판을 기둥3으로 옮겨야 함

 		  1
          2
          3
         ...
         n-2
         n-1       n
기둥1		기둥2 	기둥3

1. n-1개의 원판을 기둥1에서 기둥2로 옮긴다.
2. n번 원판을 기둥1에서 기둥 3으로 옮긴다.
3. n-1개의 원판을 기둥2에서 기둥3으로 옮긴다.
-> 원판이 n-1개일 때 옮길 수 있으면 원판이 n개일 때에도 옮길 수 있다.
원판이 1개일 때 원판을 내가 원하는 곳으로 옮길 수 있다.
원판이 k개 일 때 옮길 수 있으면 원판이 k+1개일 때에도 옮길 수 있다.

*/