배열 - (메모리 상)에 (원소)를 (연속)하게 배치한 (자료구조)
1. O(1)에 k번째 원소를 확인/변경 가능
-> 시작 주소에서 (k*원소의 자료형) 만큼 오른쪽으로 이동
2. 추가적으로 소모되는 메모리 양(=overhead)가 거의 없음
-> 리스트나 다른 자료구조들은 left, right같은게 필요해서 그런가?
3. Cache hit rate가 높음
-> 메모리 상에 데이터들이 붙어 있기떄문
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

1. 임의의 위치에 있는 원소를 확인/변경, O(1)
2. 원소를 끝에 추가 O(1)
3. 마지막 원소를 제거 O(1)
4. 임의의 위치에 원소를 추가 O(N)
5. 임의의 위치에 있는 원소를 제거 O(N)
-> 5번 직접 구현해보자