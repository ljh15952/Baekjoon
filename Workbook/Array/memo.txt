배열 - (메모리 상)에 (원소)를 (연속)하게 배치한 (자료구조)
1. O(1)에 k번째 원소를 확인/변경 가능
-> 시작 주소에서 (k*원소의 자료형) 만큼 오른쪽으로 이동
2. 추가적으로 소모되는 메모리 양(=overhead)가 거의 없음
-> 리스트나 다른 자료구조들은 left, right같은게 필요해서 그런가?
3. Cache hit rate가 높음
-> 메모리 상에 데이터들이 붙어 있기떄문
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림

1. 임의의 위치에 있는 원소를 확인/변경, O(1)
2. 원소를 끝에 추가 O(1)
3. 마지막 원소를 제거 O(1)
4. 임의의 위치에 원소를 추가 O(N)
5. 임의의 위치에 있는 원소를 제거 O(N)
-> 5번 직접 구현해보자

배열 초기화 방법
int a[21];
int b[21][21];
	
memset(a, 0, sizeof(a));
memset(b, 0, sizeof b);
	
fill(a, a+21, 0);
for(int i = 0; i < 21; i++)
	fill(b[i], b[i]+21, 0);
	
STL vector
배열과 동일한 기능을 수행하는 자료구조
배열과 마찬가지로 원소가 메모리에 연속하게 저장되어 O(1)에 인덱스를 가지고 각 원소 접근가능
but 배열과 다르게 크기를 자유자재로 늘이거나 줄일 수 있음
vector에서 = <- 대입연산자는 deep copy가 발생